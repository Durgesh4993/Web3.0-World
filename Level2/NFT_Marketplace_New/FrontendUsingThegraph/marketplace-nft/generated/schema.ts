// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
    TypedMap,
    Entity,
    Value,
    ValueKind,
    store,
    Bytes,
    BigInt,
    BigDecimal,
} from "@graphprotocol/graph-ts"

export class ActiveItem extends Entity {
    constructor(id: string) {
        super()
        this.set("id", Value.fromString(id))
    }

    save(): void {
        let id = this.get("id")
        assert(id != null, "Cannot save ActiveItem entity without an ID")
        if (id) {
            assert(
                id.kind == ValueKind.STRING,
                `Entities of type ActiveItem must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
            )
            store.set("ActiveItem", id.toString(), this)
        }
    }

    static load(id: string): ActiveItem | null {
        return changetype<ActiveItem | null>(store.get("ActiveItem", id))
    }

    get id(): string {
        let value = this.get("id")
        return value!.toString()
    }

    set id(value: string) {
        this.set("id", Value.fromString(value))
    }

    get buyer(): Bytes {
        let value = this.get("buyer")
        return value!.toBytes()
    }

    set buyer(value: Bytes) {
        this.set("buyer", Value.fromBytes(value))
    }

    get seller(): Bytes {
        let value = this.get("seller")
        return value!.toBytes()
    }

    set seller(value: Bytes) {
        this.set("seller", Value.fromBytes(value))
    }

    get nftAddress(): Bytes {
        let value = this.get("nftAddress")
        return value!.toBytes()
    }

    set nftAddress(value: Bytes) {
        this.set("nftAddress", Value.fromBytes(value))
    }

    get tokenId(): BigInt {
        let value = this.get("tokenId")
        return value!.toBigInt()
    }

    set tokenId(value: BigInt) {
        this.set("tokenId", Value.fromBigInt(value))
    }

    get price(): BigInt | null {
        let value = this.get("price")
        if (!value || value.kind == ValueKind.NULL) {
            return null
        } else {
            return value.toBigInt()
        }
    }

    set price(value: BigInt | null) {
        if (!value) {
            this.unset("price")
        } else {
            this.set("price", Value.fromBigInt(<BigInt>value))
        }
    }
}

export class itemBought extends Entity {
    constructor(id: string) {
        super()
        this.set("id", Value.fromString(id))
    }

    save(): void {
        let id = this.get("id")
        assert(id != null, "Cannot save itemBought entity without an ID")
        if (id) {
            assert(
                id.kind == ValueKind.STRING,
                `Entities of type itemBought must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
            )
            store.set("itemBought", id.toString(), this)
        }
    }

    static load(id: string): itemBought | null {
        return changetype<itemBought | null>(store.get("itemBought", id))
    }

    get id(): string {
        let value = this.get("id")
        return value!.toString()
    }

    set id(value: string) {
        this.set("id", Value.fromString(value))
    }

    get buyer(): Bytes {
        let value = this.get("buyer")
        return value!.toBytes()
    }

    set buyer(value: Bytes) {
        this.set("buyer", Value.fromBytes(value))
    }

    get nftAddress(): Bytes {
        let value = this.get("nftAddress")
        return value!.toBytes()
    }

    set nftAddress(value: Bytes) {
        this.set("nftAddress", Value.fromBytes(value))
    }

    get tokenId(): BigInt {
        let value = this.get("tokenId")
        return value!.toBigInt()
    }

    set tokenId(value: BigInt) {
        this.set("tokenId", Value.fromBigInt(value))
    }

    get price(): BigInt {
        let value = this.get("price")
        return value!.toBigInt()
    }

    set price(value: BigInt) {
        this.set("price", Value.fromBigInt(value))
    }
}

export class itemListed extends Entity {
    constructor(id: string) {
        super()
        this.set("id", Value.fromString(id))
    }

    save(): void {
        let id = this.get("id")
        assert(id != null, "Cannot save itemListed entity without an ID")
        if (id) {
            assert(
                id.kind == ValueKind.STRING,
                `Entities of type itemListed must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
            )
            store.set("itemListed", id.toString(), this)
        }
    }

    static load(id: string): itemListed | null {
        return changetype<itemListed | null>(store.get("itemListed", id))
    }

    get id(): string {
        let value = this.get("id")
        return value!.toString()
    }

    set id(value: string) {
        this.set("id", Value.fromString(value))
    }

    get seller(): Bytes {
        let value = this.get("seller")
        return value!.toBytes()
    }

    set seller(value: Bytes) {
        this.set("seller", Value.fromBytes(value))
    }

    get nftAddress(): Bytes {
        let value = this.get("nftAddress")
        return value!.toBytes()
    }

    set nftAddress(value: Bytes) {
        this.set("nftAddress", Value.fromBytes(value))
    }

    get tokenId(): BigInt {
        let value = this.get("tokenId")
        return value!.toBigInt()
    }

    set tokenId(value: BigInt) {
        this.set("tokenId", Value.fromBigInt(value))
    }

    get Price(): BigInt {
        let value = this.get("Price")
        return value!.toBigInt()
    }

    set Price(value: BigInt) {
        this.set("Price", Value.fromBigInt(value))
    }
}

export class itemRemoved extends Entity {
    constructor(id: string) {
        super()
        this.set("id", Value.fromString(id))
    }

    save(): void {
        let id = this.get("id")
        assert(id != null, "Cannot save itemRemoved entity without an ID")
        if (id) {
            assert(
                id.kind == ValueKind.STRING,
                `Entities of type itemRemoved must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
            )
            store.set("itemRemoved", id.toString(), this)
        }
    }

    static load(id: string): itemRemoved | null {
        return changetype<itemRemoved | null>(store.get("itemRemoved", id))
    }

    get id(): string {
        let value = this.get("id")
        return value!.toString()
    }

    set id(value: string) {
        this.set("id", Value.fromString(value))
    }

    get seller(): Bytes {
        let value = this.get("seller")
        return value!.toBytes()
    }

    set seller(value: Bytes) {
        this.set("seller", Value.fromBytes(value))
    }

    get nftAddress(): Bytes {
        let value = this.get("nftAddress")
        return value!.toBytes()
    }

    set nftAddress(value: Bytes) {
        this.set("nftAddress", Value.fromBytes(value))
    }

    get tokenId(): BigInt {
        let value = this.get("tokenId")
        return value!.toBigInt()
    }

    set tokenId(value: BigInt) {
        this.set("tokenId", Value.fromBigInt(value))
    }
}
